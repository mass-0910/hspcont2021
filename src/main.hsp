#include "hspdef.as"

#define global WINDOW_WIDTH 640
#define global WINDOW_HEIGHT 480
#define global MAPCHIP_HANDLER 1
#define global DIALOG_HANDLER 5
#define global MINIMAP_HANDLER 50
#define global DIALOG_SIZE_WIDTH 180
#define global DIALOG_SIZE_HEIGHT 180
#define global TANK_HANDLER 2
#define global TANK_BADGE_HANDLER 4
#define global BASE_HANDLER 3
#define global CURSOR_HANDLER 6
#define global COMMAND_BADGE_HANDLER 7
#define global PLAYER_COUNT 64
#define global ENEMY_COUNT 64
#define global PLAYER_BASE_INDEX 0
#define global ENEMY_BASE_INDEX 64
#define global MAPCHIP_ROOT_MAX 300
#define global MAPCHIP_EDGE_POINT 16
#define global TANKTYPE_MAX 1

#define global true 1
#define global false 0

// マップ上の位置を指定してカレントポジションを設定する命令
#module
    #deffunc posRelative double x, double y
        pos (x - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (y - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2
    return

    #deffunc boxfa int ax, int ay, int bx, int by
        pdx = ax, bx, bx, ax
        pdy = ay, ay, by, by
        gsquare -1, pdx, pdy
    return

    #deffunc boxfRelative double p1, double p2, double p3, double p4
        boxfa (p1 - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (p2 - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2, (p3 - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (p4 - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2
    return

    #deffunc circleRelative double p1, double p2, double p3, double p4
        circle (p1 - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (p2 - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2, (p3 - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (p4 - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2, 0
    return
#global

#module
    #deffunc psetBig int px, int py, int scale
        circle px - scale, py - scale, px + scale, py + scale
    return
#global

// マウスがクリックされた瞬間だけtrueを返す関数
left_trigger = false
right_trigger = false
#module
    #defcfunc mouseLeftClicked
        getkey a, 1
        if left_trigger@ == false && a {
            left_trigger@ = true
            return true
        }
        if a == 0 {
            left_trigger@ = false
        }
        return false

    #defcfunc mouseRightClicked
        getkey a, 2
        if right_trigger@ == false && a {
            right_trigger@ = true
            return true
        }
        if a == 0 {
            right_trigger@ = false
        }
        return false
#global

// マウスの位置をマップ上の座標に変換
#module
    #defcfunc getMousePosX
        return camera_x@ + double(mousex - WINDOW_WIDTH / 2) / camera_expand@

    #defcfunc getMousePosY
        return camera_y@ + double(mousey - WINDOW_HEIGHT / 2) / camera_expand@
#global

// バッファ上の画像のサイズを取得する関数
#module
    #defcfunc getImageWidth int handler
        draw_handler = ginfo_sel
        gsel handler
        image_width = ginfo_winx
        gsel draw_handler
        return double(image_width)

    #defcfunc getImageHeight int handler
        draw_handler = ginfo_sel
        gsel handler
        image_height = ginfo_winy
        gsel draw_handler
        return double(image_height)
#global

// 文字描画の際のサイズを取得する関数
#module
    #defcfunc getMesWidth str string
        cpx = ginfo_cx : cpy = ginfo_cy
        pos -999, -999
        mes string
        mes_width = ginfo_mesx
        pos cpx, cpy
        return double(mes_width)

    #defcfunc getMesHeight str string
        cpx = ginfo_cx : cpy = ginfo_cy
        pos -999, -999
        mes string
        mes_height = ginfo_mesy
        pos cpx, cpy
        return double(mes_height)
#global

// 矩形内に入っているかどうかを判定する関数
#module
    #defcfunc inRect double px, double py, double rx1, double ry1, double rx2, double ry2
        return (px >= rx1 && px <= rx2 && py >= ry1 && py <= ry2) || (px >= rx1 && px <= rx2 && py >= ry2 && py <= ry1) || (px >= rx2 && px <= rx1 && py >= ry1 && py <= ry2) || (px >= rx2 && px <= rx1 && py >= ry2 && py <= ry1)

    #defcfunc hitRect double r1x1, double r1y1, double r1x2, double r1y2, double r2x1, double r2y1, double r2x2, double r2y2
        return r1x1 <= r2x2 && r2x1 <= r1x2 && r1y1 <= r2y2 && r2y1 <= r1y2
#global

// 変数をある値に線形に近づける
#module
    // 整数版
    #deffunc intCloserTo var v, int x, int speed
        if v > x {
            if v - speed < x {
                v = x
            } else {
                v -= speed
            }
        } else: if v < x {
            if v + speed > x {
                v = x
            } else {
                v += speed
            }
        }
    return

    // 実数版
    #deffunc doubleCloserTo var v, double x, double speed
        if v > x {
            if v - speed < x {
                v = x
            } else {
                v -= speed
            }
        } else: if v < x {
            if v + speed > x {
                v = x
            } else {
                v += speed
            }
        }
    return
#global

// 変数を素早くある値に近づける(実数のみ)
#module
    #deffunc closerSpeedy var v, double x, double coeffect
        v += (x - v) * coeffect
    return
#global

// 指定した戦車要素にステータスをコピー
#module
    #deffunc copyStatus int index, int id
        tank_image_handler@(index) = tankdata_image_handler@(id)
        tank_image_width@(index)   = tankdata_image_width@(id)
        tank_image_height@(index)  = tankdata_image_height@(id)
        tank_hp@(index)            = tankdata_hp@(id)
        tank_attack@(index)        = tankdata_attack@(id)
        tank_defence@(index)       = tankdata_defence@(id)
        tank_speed@(index)         = tankdata_speed@(id)
    return
#global

// int型可変長リスト風モジュール
#module intList list, len, empty
    #modinit int maxLength, int emptyval
        dim list, maxLength
        len = maxLength
        empty = emptyval
        repeat len
            list(cnt) = emptyval
        loop
    return

    #modcfunc listGet int index
        return list(index)

    #modfunc listSet int index, int val
        list(index) = val
    return

    #modcfunc listLen
        count = 0
        repeat len
            if list(cnt) == empty: break
            count++
        loop
        return count

    #modfunc listAppend int val
        repeat len
            if list(cnt) == empty {
                list(cnt) = val
                break
            }
        loop
    return

    #modfunc listRemoveAt int index
        repeat len - index - 1, index
            list(cnt) = list(cnt + 1)
        loop
        list(len - 1) = empty
    return

    #modfunc listClear
        repeat len
            if list(cnt) == empty: break
            list(cnt) = empty
        loop
    return
#global

// プログラムスタート時の初期化
*start
    //スクリーンの初期化
    screen 0, WINDOW_WIDTH, WINDOW_HEIGHT
    font "ＭＳ ゴシック", 9
    title "Panzer Command"
    gmode 2

    // 乱数初期化
    randomize

    // バッファの初期化
    buffer DIALOG_HANDLER
    buffer MINIMAP_HANDLER

    // 素材のロード
    celload "..\\resources\\image\\tank.png", TANK_HANDLER
    celload "..\\resources\\image\\mapchip.png", MAPCHIP_HANDLER
    celload "..\\resources\\image\\team.png", BASE_HANDLER
    celload "..\\resources\\image\\tankbadge.png", TANK_BADGE_HANDLER
    celload "..\\resources\\image\\cursor.png", CURSOR_HANDLER
    celload "..\\resources\\image\\commandbadge.png", COMMAND_BADGE_HANDLER
    celdiv MAPCHIP_HANDLER, 18, 18, 0, 0
    celdiv TANK_HANDLER, 32, 32, 16, 16
    celdiv TANK_BADGE_HANDLER, 64, 64, 0, 0
    celdiv CURSOR_HANDLER, 64, 64, 32, 32
    celdiv COMMAND_BADGE_HANDLER, 64, 64, 0, 0

    // 配列の定義
    // tank: 戦車を表す属性(味方も敵もここで定義)
    dim tank_used, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_x, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_y, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_target_x, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_target_y, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_angle, PLAYER_COUNT + ENEMY_COUNT
    dim tank_stop, PLAYER_COUNT + ENEMY_COUNT
    dim tank_image_handler, PLAYER_COUNT + ENEMY_COUNT
    dim tank_image_width, PLAYER_COUNT + ENEMY_COUNT
    dim tank_image_height, PLAYER_COUNT + ENEMY_COUNT
    dim tank_hp, PLAYER_COUNT + ENEMY_COUNT
    dim tank_attack, PLAYER_COUNT + ENEMY_COUNT
    dim tank_defence, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_speed, PLAYER_COUNT + ENEMY_COUNT
    // mapchip: マップチップの属性
    dim mapchip_div_id, MAPCHIP_ROOT_MAX, MAPCHIP_ROOT_MAX
    // seltank: 出撃戦車ダイアログの属性
    dim seltank_tankbutton_image, 5
    dim seltank_tankbutton_tankid, 5
    // tankdata: 戦車のステータス情報
    dim tankdata_image_handler, TANKTYPE_MAX
    dim tankdata_image_width, TANKTYPE_MAX
    dim tankdata_image_height, TANKTYPE_MAX
    dim tankdata_hp, TANKTYPE_MAX
    dim tankdata_attack, TANKTYPE_MAX
    dim tankdata_defence, TANKTYPE_MAX
    ddim tankdata_speed, TANKTYPE_MAX

    // モジュール変数の初期化
    newmod selected_tank_index_list, intList, 64, 9999999999999

    // 戦車情報のロード
    //TODO: とりあえず
    repeat TANKTYPE_MAX
        tankdata_image_handler(cnt) = TANK_HANDLER
        tankdata_image_width(cnt)   = getImageWidth(tankdata_image_handler(cnt))
        tankdata_image_height(cnt)  = getImageHeight(tankdata_image_handler(cnt))
        tankdata_hp(cnt)            = 30
        tankdata_attack(cnt)        = 50
        tankdata_defence(cnt)       = 10
        tankdata_speed(cnt)         = 0.75
    loop

// ゲームリスタート時の初期化
*init
    //各種変数の初期化
    camera_x = 0.0 //カメラ左上x座標
    camera_y = 0.0 //カメラ左上y座標
    repeat PLAYER_COUNT + ENEMY_COUNT
        tank_used(cnt) = false
    loop

// ゲーム初期化
*gameinit
    ; notesel fieldtext
    ; noteload ""

    //TODO: とりあえず
    repeat MAPCHIP_ROOT_MAX
        y = cnt
        repeat MAPCHIP_ROOT_MAX
            x = cnt
            mapchip_div_id(x, y) = 0
        loop
    loop
    field_width_max = MAPCHIP_ROOT_MAX * MAPCHIP_EDGE_POINT
    field_height_max = MAPCHIP_ROOT_MAX * MAPCHIP_EDGE_POINT
    gosub *game_init_minimap
    player_castle_x = (double(MAPCHIP_ROOT_MAX) * double(MAPCHIP_EDGE_POINT)) / 2.0
    player_castle_y = ((double(MAPCHIP_ROOT_MAX) - 25.0) * double(MAPCHIP_EDGE_POINT)) - double(MAPCHIP_EDGE_POINT) / 2.0
    enemy_castle_x = (double(MAPCHIP_ROOT_MAX) * double(MAPCHIP_EDGE_POINT)) / 2.0
    enemy_castle_y = (25.0 * double(MAPCHIP_EDGE_POINT)) - double(MAPCHIP_EDGE_POINT) / 2.0

    camera_x = player_castle_x
    camera_y = player_castle_y
    camera_expand = 1.0

    dialog_alpha = 0

    click_counter = 0

    mode_focus_castle = false
    mode_focus_tank = false
    mode_dialog = false
    mode_command_ahead = false

    log_publish = false
    log_buffer = ""

    select_area_x1 = -1
    select_area_y1 = -1
    select_area_x2 = -1
    select_area_y2 = -1

    counter = 0

// ゲームループ
*gameloop
    redraw 0

    // 背景描画
    base_x = int((camera_x - double(WINDOW_WIDTH / 2) / camera_expand) / MAPCHIP_EDGE_POINT)
    base_y = int((camera_y - double(WINDOW_HEIGHT / 2) / camera_expand) / MAPCHIP_EDGE_POINT)
    ; base_y = int(camera_y / MAPCHIP_EDGE_POINT) - int(double(WINDOW_HEIGHT / MAPCHIP_EDGE_POINT / 2) * (1.0 / camera_expand))
    repeat WINDOW_HEIGHT / (double(MAPCHIP_EDGE_POINT) * camera_expand) + 1
        y = cnt
        repeat WINDOW_WIDTH / (double(MAPCHIP_EDGE_POINT) * camera_expand) + 1
            x = cnt
            posRelative (base_x + x) * MAPCHIP_EDGE_POINT, (base_y + y) * MAPCHIP_EDGE_POINT
            if base_x + x <  0: refx = 0: else: if base_x + x >= MAPCHIP_ROOT_MAX: refx = MAPCHIP_ROOT_MAX - 1: else: refx = base_x + x
            if base_y + y <  0: refy = 0: else: if base_y + y >= MAPCHIP_ROOT_MAX: refy = MAPCHIP_ROOT_MAX - 1: else: refx = base_y + y
            celput MAPCHIP_HANDLER, mapchip_div_id(refx, refy), camera_expand, camera_expand
        loop
    loop

    // 陣地描画
    posRelative player_castle_x - getImageWidth(BASE_HANDLER) / 2, player_castle_y - getImageHeight(BASE_HANDLER) / 2
    celput BASE_HANDLER, 0, camera_expand, camera_expand

    // 自陣選択モードのとき
    if mode_focus_castle {
        // カーソルを自陣に描画
        posRelative player_castle_x, player_castle_y
        celput CURSOR_HANDLER, int(counter / 20) \ 2, 2.0 * camera_expand, 2.0 * camera_expand
        // 出撃可能範囲を描画
        color 0, 255, 0
        circleRelative player_castle_x - 128, player_castle_y - 128, player_castle_x + 128, player_castle_y + 128
        posRelative player_castle_x, player_castle_y - 128
        px = ginfo_cx : py = ginfo_cy
        pos px - getMesWidth("出撃可能範囲") / 2, py - getMesHeight("出撃可能範囲")
        objcolor 0, 0, 0
        mes "出撃可能範囲", mesopt_outline
    }

    // 戦車描画
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_used(cnt) {
            posRelative tank_x(cnt), tank_y(cnt)
            celput tank_image_handler(cnt), 0, camera_expand, camera_expand, tank_angle(cnt)
        }
    loop

    // 戦車選択モードのとき
    if mode_focus_tank {
        // カーソルを選択した戦車に描画
        repeat listLen(selected_tank_index_list)
            posRelative tank_x(listGet(selected_tank_index_list, cnt)), tank_y(listGet(selected_tank_index_list, cnt))
            celput CURSOR_HANDLER, int(counter / 20) \ 2, 0.5 * camera_expand, 0.5 * camera_expand
        loop
    }

    // 選択範囲描画
    getkey a, 1: if a && mode_focus_castle == false && mode_focus_tank == false{
        color 100, 100, 255
        gmode 3, , , 128
        boxfRelative select_area_x1, select_area_y1, select_area_x2, select_area_y2
        gmode 2
    }

    // ダイアログ描画
    gsel DIALOG_HANDLER
    color 0, 0, 0
    boxf
    gsel 0
    gmode 3, , , dialog_alpha
    pos WINDOW_WIDTH - DIALOG_SIZE_WIDTH, 0
    gcopy DIALOG_HANDLER, 0, 0, DIALOG_SIZE_WIDTH, DIALOG_SIZE_HEIGHT
    gmode 2

    // ダイアログ透過率
    if mode_dialog {
        intCloserTo dialog_alpha, 255, 20
    } else {
        intCloserTo dialog_alpha, 0, 20
    }

    // 出撃戦車選択モードのとき、自陣ダイアログを描画
    if mode_focus_castle {
        // 背景描画
        color 0, 0, 0
        boxf 0, WINDOW_HEIGHT - 100, WINDOW_WIDTH, WINDOW_HEIGHT
        // メッセージ描画
        pos 5, WINDOW_HEIGHT - 100 + 5
        color 255, 255, 255
        mes "プレイヤー拠点"
        // バツボタン描画
        color 150, 150, 150
        boxf WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70
        color 0, 0, 0
        line WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70
        line WINDOW_WIDTH - 10, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 30, WINDOW_HEIGHT - 70
        // 戦車ボタン描画
        repeat 5
            pos 74 * cnt + 10, WINDOW_HEIGHT - 82
            celput TANK_BADGE_HANDLER, 0
        loop
    }

    // 戦車フォーカルモードのとき、戦車命令ダイアログを描画
    if mode_focus_tank {
        // 背景描画
        color 0, 0, 0
        boxf 0, WINDOW_HEIGHT - 100, WINDOW_WIDTH, WINDOW_HEIGHT
        // メッセージ描画
        pos 5, WINDOW_HEIGHT - 100 + 5
        color 255, 255, 255
        mes "コマンド"
        // バツボタン描画
        color 150, 150, 150
        boxf WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70
        color 0, 0, 0
        line WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70
        line WINDOW_WIDTH - 10, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 30, WINDOW_HEIGHT - 70
        // 戦車ボタン描画
        repeat 4
            pos 74 * cnt + 10, WINDOW_HEIGHT - 82
            celput COMMAND_BADGE_HANDLER, cnt
        loop
    }

    // 目的地選択コマンドモードのとき、マップを描画
    if mode_command_ahead {
        gosub *game_draw_minimap
    }

    // フォーカスモードでないときマウス操作
    if mode_focus_castle == false && mode_focus_tank == false{
        // カメラ操作(キーボード)
        getkey a, 37: if a: camera_x -= 10.0
        getkey a, 38: if a: camera_y -= 10.0
        getkey a, 39: if a: camera_x += 10.0
        getkey a, 40: if a: camera_y += 10.0

        // カメラ操作(マウス)
        getkey a, 2: if a{
            camera_x -= int(double(mousex - before_mx) * (1.0 / camera_expand))
            camera_y -= int(double(mousey - before_my) * (1.0 / camera_expand))
        }

        // 範囲指定
        getkey a, 1: if a {
            select_area_x2 = getMousePosX()
            select_area_y2 = getMousePosY()
        } else {
            // フィールドにある戦車を選択
            if select_area_x1 != -1 && select_area_y1 != -1 && select_area_x2 != -1 && select_area_y2 != -1 {
                gosub *game_area_select_player_tank
                if listLen(selected_tank_index_list) != 0 {
                    mode_focus_tank = true
                }
            }
            select_area_x1 = -1
            select_area_y1 = -1
            select_area_x2 = -1
            select_area_y2 = -1
        }
    }
    before_mx = mousex
    before_my = mousey

    // 自陣フォーカスモードのとき物体にカメラを近づける
    if mode_focus_castle {
        closerSpeedy camera_x, player_castle_x, 0.1
        closerSpeedy camera_y, player_castle_y, 0.1
    }

    // 戦車フォーカスモードのとき物体にカメラを近づける
    if mode_focus_tank {
        // 選択された戦車の重心を求める
        selected_tank_gx = 0.0
        selected_tank_gy = 0.0
        repeat listLen(selected_tank_index_list)
            selected_tank_gx += tank_x(listGet(selected_tank_index_list, cnt))
            selected_tank_gy += tank_y(listGet(selected_tank_index_list, cnt))
        loop
        selected_tank_gx /= double(listLen(selected_tank_index_list))
        selected_tank_gy /= double(listLen(selected_tank_index_list))
        closerSpeedy camera_x, selected_tank_gx, 0.1
        closerSpeedy camera_y, selected_tank_gy, 0.1
    }

    // マウスホイールによる拡大縮小
    diff = double(mousew - before_mw) * 0.001
    camera_expand += diff
    if camera_expand > 2.0: camera_expand = 2.0
    if camera_expand < 0.4: camera_expand = 0.4
    before_mw = mousew

    // カメラの範囲外抑制
    if camera_x - double(WINDOW_WIDTH / 2) / camera_expand < 0 {
        camera_x = double(WINDOW_WIDTH / 2) / camera_expand
    } else: if camera_x + double(WINDOW_WIDTH / 2) / camera_expand > field_width_max {
        camera_x = field_width_max - double(WINDOW_WIDTH / 2) / camera_expand
    }
    if camera_y < double(WINDOW_HEIGHT / 2) / camera_expand {
        camera_y = double(WINDOW_HEIGHT / 2) / camera_expand
    } else: if camera_y + double(WINDOW_HEIGHT / 2) / camera_expand > field_height_max {
        camera_y = field_height_max - double(WINDOW_HEIGHT / 2) / camera_expand
    }

    // 画面がクリックされたとき
    if mouseLeftClicked() {
        gosub *game_mouseleftclicked
    }
    if mouseRightClicked() {
        gosub *game_mouserightclicked
    }

    // 戦車の動き
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_used(cnt) && tank_stop(cnt) == false {
            tank_angle(cnt) = atan(tank_target_y(cnt) - tank_y(cnt), tank_target_x(cnt) - tank_x(cnt))
            tank_x(cnt) += cos(tank_angle(cnt)) * tank_speed(cnt)
            tank_y(cnt) += sin(tank_angle(cnt)) * tank_speed(cnt)
        }
    loop

    redraw 1
    await 16
    counter++
    goto *gameloop

// ゲーム中にマウス左ボタンがクリックされたときのサブルーチン
*game_mouseleftclicked
    mx = getMousePosX()
    my = getMousePosY()

    if inRect(mx, my, player_castle_x - 64, player_castle_y - 64, player_castle_x + 64, player_castle_y + 64) && mode_focus_castle == false && mode_focus_tank == false{ // 自陣をクリックしたとき
        mode_focus_castle = true
        return
    }

    // 戦車選択ダイアログでのマウスの動作
    if mode_focus_castle {
        if inRect(mousex, mousey, WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70) { //バツボタンが押されたとき
            mode_focus_castle = false
            return
        }
        repeat 5
            if inRect(mousex, mousey, 74 * cnt + 10, WINDOW_HEIGHT - 82, 74 * cnt + 10 + 64, WINDOW_HEIGHT - 82 + 64) {
                launch_tank_id = 0
                gosub *game_playertank_launch
            }
        loop
        return
    }

    // 戦車フォーカスモードでのマウスの動作
    if mode_focus_tank && mode_command_ahead == false{
        if inRect(mousex, mousey, WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70) { //バツボタンが押されたとき
            mode_focus_tank = false
            return
        }
        repeat 5
            if inRect(mousex, mousey, 74 * cnt + 10, WINDOW_HEIGHT - 82, 74 * cnt + 10 + 64, WINDOW_HEIGHT - 82 + 64) {
                switch cnt
                    case 0: // 目的地選択
                        mode_command_ahead = true
                        swbreak
                    case 1: // 動く
                        repeat listLen(selected_tank_index_list)
                            tank_stop(listGet(selected_tank_index_list, cnt)) = false
                        loop
                        swbreak
                    case 2: // 停まる
                        repeat listLen(selected_tank_index_list)
                            tank_stop(listGet(selected_tank_index_list, cnt)) = true
                        loop
                        swbreak
                swend
            }
        loop
    }

    // 目的地選択
    if mode_command_ahead {
        if inRect(mousex, mousey, minimap_base_x, minimap_base_y, minimap_base_x + field_width_max / double(MAPCHIP_EDGE_POINT), minimap_base_y + field_height_max / double(MAPCHIP_EDGE_POINT)) {
            repeat listLen(selected_tank_index_list)
                tank_target_x(listGet(selected_tank_index_list, cnt)) = double(mousex * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2 - minimap_base_x * MAPCHIP_EDGE_POINT)
                tank_target_y(listGet(selected_tank_index_list, cnt)) = double(mousey * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2 - minimap_base_y * MAPCHIP_EDGE_POINT)
                title str(tank_target_x(listGet(selected_tank_index_list, cnt))) + str(tank_target_y(listGet(selected_tank_index_list, cnt)))
                tank_stop(listGet(selected_tank_index_list, cnt)) = false
            loop
        }
    }

    // 選択範囲指定の最初地点の設定
    select_area_x1 = mx
    select_area_y1 = my
return

// ゲーム中にマウス右ボタンがクリックされたときのサブルーチン
*game_mouserightclicked
    mx = getMousePosX()
    my = getMousePosY()

    if mode_focus_castle {
        mode_focus_castle = false
    }

    if mode_focus_tank && mode_command_ahead == false{
        mode_focus_tank = false
        listClear selected_tank_index_list
    }

    if mode_command_ahead {
        mode_command_ahead = false
    }
return

// 味方戦車をマップに出現させる処理
*game_playertank_launch
    repeat PLAYER_COUNT
        if tank_used(cnt) == false {
            tank_used(cnt) = true
            copyStatus cnt, launch_tank_id
            tank_angle(cnt) = (3.0 * M_PI) / 2.0
            tank_stop(cnt) = true
            launch_id = cnt
            gosub *game_playertank_launch_placement
            break
        }
    loop
return

*game_playertank_launch_placement
    tank_x(launch_id) = player_castle_x
    tank_y(launch_id) = player_castle_y - 128
    launch_counter = 1000
    repeat PLAYER_COUNT + ENEMY_COUNT
        if launch_id == cnt: continue
        if launch_counter == 0 {
            log_publish = true
            log_buffer = "出撃可能な範囲がありません"
            tank_used(launch_id) = false
            break
        }
        if tank_used(cnt) && hitRect(tank_x(launch_id) - 16, tank_y(launch_id) - 16, tank_x(launch_id) + 16, tank_y(launch_id) + 16, tank_x(cnt) - 16, tank_y(cnt) - 16, tank_x(cnt) + 16, tank_y(cnt) + 16) {
            rand_angle = deg2rad(rnd(360))
            rand_r = 32 + rnd(128 - 32)
            tank_x(launch_id) = cos(rand_angle) * rand_r + player_castle_x
            tank_y(launch_id) = sin(rand_angle) * rand_r + player_castle_y
            tank_target_x(launch_id) = cos(rand_angle) * rand_r + player_castle_x
            tank_target_y(launch_id) = sin(rand_angle) * rand_r + player_castle_y
            launch_counter--
            continue 0
        }
    loop
return

*game_area_select_player_tank
    listClear selected_tank_index_list
    repeat PLAYER_COUNT
        if tank_used(cnt) == false: continue
        if inRect(tank_x(cnt), tank_y(cnt), select_area_x1, select_area_y1, select_area_x2, select_area_y2) {
            listAppend selected_tank_index_list, cnt
        }
    loop
return

*game_init_minimap
    gsel MINIMAP_HANDLER
    repeat field_height_max / MAPCHIP_EDGE_POINT
        x = cnt
        repeat field_width_max / MAPCHIP_EDGE_POINT
            y = cnt
            color 0, 255, 0
            pset x, y
        loop
    loop
    gsel 0
return

*game_draw_minimap
    // 基準点
    minimap_base_x = WINDOW_WIDTH / 2 - (field_width_max / MAPCHIP_EDGE_POINT) / 2
    minimap_base_y = WINDOW_HEIGHT / 2 - (field_height_max / MAPCHIP_EDGE_POINT) / 2
    // マップ描画
    pos minimap_base_x, minimap_base_y
    gmode 0
    gcopy MINIMAP_HANDLER, 0, 0, field_width_max / MAPCHIP_EDGE_POINT, field_height_max / MAPCHIP_EDGE_POINT
    // 戦車の位置の描画
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_used(cnt) {
            if cnt < ENEMY_BASE_INDEX {
                color 0, 0, 255
            } else {
                color 255, 0, 0
            }
            psetBig minimap_base_x + tank_x(cnt) / double(MAPCHIP_EDGE_POINT), minimap_base_y + tank_y(cnt) / double(MAPCHIP_EDGE_POINT), 2
        }
    loop
    // 自陣描画
    color 0, 0, 0
    psetBig minimap_base_x + player_castle_x / double(MAPCHIP_EDGE_POINT), minimap_base_y + player_castle_y / double(MAPCHIP_EDGE_POINT), 2
    gmode 2
return