#runtime "hsp3utf"
#include "hspdef.as"

#define global WINDOW_WIDTH 640
#define global WINDOW_HEIGHT 480
#define global MAPCHIP_HANDLER 1
#define global DIALOG_HANDLER 5
#define global MINIMAP_BUFFER 50
#define global DIALOG_SIZE_WIDTH 180
#define global DIALOG_SIZE_HEIGHT 180
#define global TANK_HANDLER 2
#define global TANK_BADGE_HANDLER 4
#define global BASE_HANDLER 3
#define global CURSOR_HANDLER 6
#define global COMMAND_BADGE_HANDLER 7
#define global MAPBUTTON_HANDLER 8
#define global FORMATIONBUTTON_HANDLER 9
#define global FLAG_HANDLER 10
#define global MES_SIZE_BUFFER 51
#define global MAPFIELD_BUFFER 52
#define global MAPINFO_BUFFER 53
#define global PLAYER_COUNT 64
#define global ENEMY_COUNT 64
#define global PLAYER_BASE_INDEX 0
#define global ENEMY_BASE_INDEX 64
#define global MAPCHIP_ROOT_MAX 300
#define global MAPCHIP_EDGE_POINT 16
#define global BULLET_HANDLER 11
#define global TANKTYPE_MAX 6
#define global COMPAMYFORMATION_VERTICAL   0
#define global COMPAMYFORMATION_HORIZONTAL 1
#define global COMPAMYFORMATION_PANZERKEIL 2
#define global COMPAMYFORMATION_OFF        3
#define global OPERATION_ATTACK_TO_NEAR      0
#define global OPERATION_ATTACK_TO_STRONGER  1
#define global OPERATION_ATTACK_TO_SPECIFIED 2
#define global OPERATION_IGNORE              3

#define global true 1
#define global false 0

// マップ上の位置を指定してカレントポジションを設定する命令
#module
    #deffunc posRelative double x, double y
        pos (x - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (y - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2
    return

    #deffunc boxfa int ax, int ay, int bx, int by
        pdx = ax, bx, bx, ax
        pdy = ay, ay, by, by
        gsquare -1, pdx, pdy
    return

    #deffunc boxfr int ax, int ay, int bx, int by
        line ax, ay, ax, by
        line ax, by, bx, by
        line bx, by, bx, ay
        line bx, ay, ax, ay
    return

    #deffunc lineRelative double p1, double p2, double p3, double p4
        line (p1 - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (p2 - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2, (p3 - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (p4 - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2
    return

    #deffunc boxfRelative double p1, double p2, double p3, double p4
        boxfa (p1 - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (p2 - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2, (p3 - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (p4 - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2
    return

    #deffunc circleRelative double p1, double p2, double p3, double p4
        circle (p1 - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (p2 - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2, (p3 - camera_x@) * camera_expand@ + WINDOW_WIDTH / 2, (p4 - camera_y@) * camera_expand@ + WINDOW_HEIGHT / 2, 0
    return
#global

#module
    #deffunc psetBig int px, int py, int scale
        circle px - scale, py - scale, px + scale, py + scale
    return
#global

// マウスがクリックされた瞬間だけtrueを返す関数
#module
    left_trigger = false
    right_trigger = false
    #defcfunc mouseLeftClicked
        getkey a, 1
        if left_trigger == false && a {
            left_trigger = true
            return true
        }
        if a == 0 {
            left_trigger = false
        }
        return false

    #defcfunc mouseRightClicked
        getkey a, 2
        if right_trigger == false && a {
            right_trigger = true
            return true
        }
        if a == 0 {
            right_trigger = false
        }
        return false
#global

// マウスの位置をマップ上の座標に変換
#module
    #defcfunc getMousePosX
        return camera_x@ + double(mousex - WINDOW_WIDTH / 2) / camera_expand@

    #defcfunc getMousePosY
        return camera_y@ + double(mousey - WINDOW_HEIGHT / 2) / camera_expand@
#global

// バッファ上の画像のサイズを取得する関数
#module
    #defcfunc getImageWidth int handler
        draw_handler = ginfo_sel
        gsel handler
        image_width = ginfo_winx
        gsel draw_handler
        return image_width

    #defcfunc getImageHeight int handler
        draw_handler = ginfo_sel
        gsel handler
        image_height = ginfo_winy
        gsel draw_handler
        return image_height
#global

// 文字描画の際のサイズを取得する関数
#module
    #defcfunc getMesWidth str string
        cpx = ginfo_cx : cpy = ginfo_cy
        pos -999, -999
        mes string
        mes_width = ginfo_mesx
        pos cpx, cpy
        return double(mes_width)

    #defcfunc getMesHeight str string
        cpx = ginfo_cx : cpy = ginfo_cy
        pos -999, -999
        mes string
        mes_height = ginfo_mesy
        pos cpx, cpy
        return double(mes_height)
#global

// 矩形内に入っているかどうかを判定する関数
#module
    #defcfunc inRect double px, double py, double rx1, double ry1, double rx2, double ry2
        return (px >= rx1 && px <= rx2 && py >= ry1 && py <= ry2) || (px >= rx1 && px <= rx2 && py >= ry2 && py <= ry1) || (px >= rx2 && px <= rx1 && py >= ry1 && py <= ry2) || (px >= rx2 && px <= rx1 && py >= ry2 && py <= ry1)

    #defcfunc hitRect double r1x1, double r1y1, double r1x2, double r1y2, double r2x1, double r2y1, double r2x2, double r2y2
        return r1x1 <= r2x2 && r2x1 <= r1x2 && r1y1 <= r2y2 && r2y1 <= r1y2
#global

// 変数をある値に線形に近づける
#module
    // 整数版
    #deffunc intCloserTo var v, int x, int speed
        if v > x {
            if v - speed < x {
                v = x
            } else {
                v -= speed
            }
        } else: if v < x {
            if v + speed > x {
                v = x
            } else {
                v += speed
            }
        }
    return

    // 実数版
    #deffunc doubleCloserTo var v, double x, double speed
        if v > x {
            if v - speed < x {
                v = x
            } else {
                v -= speed
            }
        } else: if v < x {
            if v + speed > x {
                v = x
            } else {
                v += speed
            }
        }
    return
#global

// 変数を素早くある値に近づける(実数のみ)
#module
    #deffunc closerSpeedy var v, double x, double coeffect
        v += (x - v) * coeffect
    return
#global

// 距離を求める
#module
    #defcfunc distance double x1, double y1, double x2, double y2
        return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))
#global

// 指定した戦車要素にステータスをコピー
#module
    #deffunc copyStatus int index, int id
        tank_id@(index)            = id
        tank_image_handler@(index) = tankdata_image_handler@(id)
        tank_image_width@(index)   = tankdata_image_width@(id)
        tank_image_height@(index)  = tankdata_image_height@(id)
        tank_hp@(index)            = tankdata_hp@(id)
        tank_attack@(index)        = tankdata_attack@(id)
        tank_defence@(index)       = tankdata_defence@(id)
        tank_speed@(index)         = tankdata_speed@(id)
        tank_range@(index)         = tankdata_range@(id)
        tank_visible_range@(index) = tankdata_visible_range@(id)
    return
#global

// int型可変長リスト風モジュール
#module intList list, p
    #modinit int maxLength
        dim list, maxLength
        maxlen = maxLength
        p = 0
    return

    #modcfunc listGet int index
        if index >= p: return 0
        return list(index)

    #modfunc listSet int index, int val
        if index >= p: return
        list(index) = val
    return

    #modcfunc listLen
        return p

    #modfunc listAppend int val
        list(p) = val
        p++
    return

    #modfunc listRemoveAt int index
        if index >= p: return
        repeat p - index - 1, index
            list(cnt) = list(cnt + 1)
        loop
        p--
    return

    #modfunc listRemoveVal int val
        c = 0
        while c < p
            if list(c) == val {
                repeat p - c - 1, c
                    list(cnt) = list(cnt + 1)
                loop
                p--
                _continue
            }
            c++
        wend
    return

    #modfunc listClear
        p = 0
    return

    #modcfunc listContains int val
        retval = false
        repeat p
            if list(cnt) == val {
                retval = true
                break
            }
        loop
        return retval

    #modfunc listShuffle
        repeat p
            r         = cnt + rnd(p - cnt)
            temp      = list(r)
            list(r)   = list(cnt)
            list(cnt) = temp
        loop
    return
#global

// 中隊戦車(隊長以外)が居るべき場所を返す
#module
    #deffunc companyFormationPosition var x, var y, int me, double space
        leader_x = tank_x@(tank_company_leader@(me))
        leader_y = tank_y@(tank_company_leader@(me))
        leader_angle = tank_angle@(tank_company_leader@(me))
        switch tank_company_formation@(me)
            case COMPAMYFORMATION_VERTICAL: // 縦隊
                x = leader_x - cos(leader_angle) * space * double(tank_company_number@(me))
                y = leader_y - sin(leader_angle) * space * double(tank_company_number@(me))
                swbreak
            case COMPAMYFORMATION_HORIZONTAL: // 横隊
                if tank_company_number@(me) \ 2 {
                    LorR = -1.0
                } else {
                    LorR = 1.0
                }
                x = leader_x + cos(leader_angle + ((M_PI / 2.0) * LorR)) * space * double((tank_company_number@(me) - 1) / 2 + 1)
                y = leader_y + sin(leader_angle + ((M_PI / 2.0) * LorR)) * space * double((tank_company_number@(me) - 1) / 2 + 1)
                swbreak
            case COMPAMYFORMATION_PANZERKEIL: // パンツァーカイル
                if tank_company_number@(me) \ 2 {
                    LorR = -1.0
                } else {
                    LorR = 1.0
                }
                x = leader_x + cos(leader_angle + ((M_PI * 3.0 / 4.0) * LorR)) * space * double((tank_company_number@(me) - 1) / 2 + 1)
                y = leader_y + sin(leader_angle + ((M_PI * 3.0 / 4.0) * LorR)) * space * double((tank_company_number@(me) - 1) / 2 + 1)
                swbreak
        swend
    return
#global

#module
    #deffunc mesExpand str string, int r, int g, int b, int fontsize, int fontstyle, double expand, var size_width, var size_height
        draw_handler = ginfo_sel
        gsel MES_SIZE_BUFFER
        pos 0, 0
        color 0, 0, 0
        boxf
        font "ＭＳ ゴシック", fontsize, fontstyle
        objcolor 1, 1, 1
        color r, g, b
        mes string, mesopt_outline
        size_width = ginfo_mesx
        size_height = ginfo_mesy
        gsel draw_handler
        celput MES_SIZE_BUFFER, , expand, expand
    return
#global

// 攻撃によるダメージ計算
#module
    #deffunc attack int from, int to, var damage
        if rnd(10) == 0 {
            damage = -1
            return
        }
        damage = int(double(tank_attack@(from)) - double(tank_attack@(from)) / 4.0 + double(rnd(int(double(tank_attack@(from)) / 2.0))) - double(tank_defence@(to)))
        if damage < 0: damage = 0
        tank_hp@(to) -= damage
    return
#global

// プログラムスタート時の初期化
*start
    //スクリーンの初期化
    screen 0, WINDOW_WIDTH, WINDOW_HEIGHT
    font "ＭＳ ゴシック", 9
    title "Panzer Command"
    gmode 2

    // 乱数初期化
    randomize

    // バッファの初期化
    buffer DIALOG_HANDLER
    buffer MINIMAP_BUFFER, MAPCHIP_ROOT_MAX, MAPCHIP_ROOT_MAX
    buffer MES_SIZE_BUFFER

    // 素材のロード
    celload "..\\resources\\image\\tank.png", TANK_HANDLER
    celload "..\\resources\\image\\mapchip.png", MAPCHIP_HANDLER
    celload "..\\resources\\image\\team.png", BASE_HANDLER
    celload "..\\resources\\image\\tankbadge.png", TANK_BADGE_HANDLER
    celload "..\\resources\\image\\cursor.png", CURSOR_HANDLER
    celload "..\\resources\\image\\commandbadge.png", COMMAND_BADGE_HANDLER
    celload "..\\resources\\image\\mapbutton.png", MAPBUTTON_HANDLER
    celload "..\\resources\\image\\formation.png", FORMATIONBUTTON_HANDLER
    celload "..\\resources\\image\\flag.png", FLAG_HANDLER
    celload "..\\resources\\image\\bullet.png", BULLET_HANDLER
    celdiv MAPCHIP_HANDLER, 18, 18, 0, 0
    celdiv TANK_HANDLER, 32, 32, 16, 16
    celdiv TANK_BADGE_HANDLER, 64, 64, 0, 0
    celdiv CURSOR_HANDLER, 64, 64, 32, 32
    celdiv COMMAND_BADGE_HANDLER, 64, 64, 0, 0
    celdiv FORMATIONBUTTON_HANDLER, 64, 64, 0, 0
    celdiv BULLET_HANDLER, 64, 64, 32, 32

    // 配列の定義
    // tank: 戦車を表す属性(味方も敵もここで定義)
    dim tank_used, PLAYER_COUNT + ENEMY_COUNT
    dim tank_selected, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_x, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_y, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_target_x, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_target_y, PLAYER_COUNT + ENEMY_COUNT
    dim tank_target_selected, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_angle, PLAYER_COUNT + ENEMY_COUNT
    dim tank_stop, PLAYER_COUNT + ENEMY_COUNT
    dim tank_image_handler, PLAYER_COUNT + ENEMY_COUNT
    dim tank_image_width, PLAYER_COUNT + ENEMY_COUNT
    dim tank_image_height, PLAYER_COUNT + ENEMY_COUNT
    dim tank_hp, PLAYER_COUNT + ENEMY_COUNT
    dim tank_attack, PLAYER_COUNT + ENEMY_COUNT
    dim tank_defence, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_speed, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_visible_range, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_range, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_bullet_x, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_bullet_y, PLAYER_COUNT + ENEMY_COUNT
    dim tank_bullet_to, PLAYER_COUNT + ENEMY_COUNT
    dim tank_id, PLAYER_COUNT + ENEMY_COUNT
    dim tank_found, PLAYER_COUNT + ENEMY_COUNT
    dim tank_found_timer, PLAYER_COUNT + ENEMY_COUNT
    dim tank_reload_time, PLAYER_COUNT + ENEMY_COUNT
    dim tank_aiming, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_aim_x, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_aim_y, PLAYER_COUNT + ENEMY_COUNT
    dim tank_damaged_amount, PLAYER_COUNT + ENEMY_COUNT
    dim tank_damaged_display_time, PLAYER_COUNT + ENEMY_COUNT
    dim tank_operation, PLAYER_COUNT + ENEMY_COUNT
    dim tank_company, PLAYER_COUNT + ENEMY_COUNT
    dim tank_company_number, PLAYER_COUNT + ENEMY_COUNT
    dim tank_company_formation, PLAYER_COUNT + ENEMY_COUNT
    dim tank_company_leader, PLAYER_COUNT + ENEMY_COUNT
    ddim tank_company_speed, PLAYER_COUNT + ENEMY_COUNT
    // mapchip: マップチップの属性
    dim mapchip_div_id, MAPCHIP_ROOT_MAX, MAPCHIP_ROOT_MAX
    // seltank: 出撃戦車ダイアログの属性
    dim seltank_tankbutton_image, 5
    dim seltank_tankbutton_tankid, 5
    // tankdata: 戦車のステータス情報
    sdim tankdata_name, 16, TANKTYPE_MAX
    dim tankdata_image_handler, TANKTYPE_MAX
    dim tankdata_image_width, TANKTYPE_MAX
    dim tankdata_image_height, TANKTYPE_MAX
    dim tankdata_cost, TANKTYPE_MAX
    dim tankdata_hp, TANKTYPE_MAX
    dim tankdata_attack, TANKTYPE_MAX
    dim tankdata_defence, TANKTYPE_MAX
    ddim tankdata_speed, TANKTYPE_MAX
    ddim tankdata_visible_range, TANKTYPE_MAX
    ddim tankdata_range, TANKTYPE_MAX
    dim tankdata_reload_time, TANKTYPE_MAX

    // モジュール変数の初期化
    newmod selected_tank_index_list, intList, 64 // 選択中の戦車
    newmod specified_tank_index_list, intList, 64 // 優先攻撃対象の戦車

    // 戦車情報のロード
    notesel note
    noteload "..\\resources\\textdata\\player_tank_data"
    dim attrs, 9
    repeat notemax
        noteget l, cnt + 1
        split l, ",", attrs_with_space
        repeat length(attrs)
            attrs(cnt) = strtrim(attrs_with_space(cnt), 0, ' ')
        loop
        tankdata_image_handler(cnt) = TANK_HANDLER
        tankdata_image_width(cnt)   = getImageWidth(tankdata_image_handler(cnt))
        tankdata_image_height(cnt)  = getImageHeight(tankdata_image_handler(cnt))
        tankdata_name(cnt)          = attrs(0)
        tankdata_cost(cnt)          = int(attrs(1))
        tankdata_hp(cnt)            = int(attrs(2))
        tankdata_attack(cnt)        = int(attrs(3))
        tankdata_defence(cnt)       = int(attrs(4))
        tankdata_speed(cnt)         = double(attrs(5))
        tankdata_range(cnt)         = double(attrs(6))
        tankdata_visible_range(cnt) = double(attrs(7))
        tankdata_reload_time(cnt)   = int(attrs(8))
    loop

// ゲームリスタート時の初期化
*init


/********************************************* ゲーム本体 ************************************************/

// ゲーム初期化
*gameinit
    //戦車配列の初期化
    repeat PLAYER_COUNT + ENEMY_COUNT
        tank_used(cnt) = false
    loop

    // フィールド情報のロード
    //TODO: とりあえず
    celload "..\\resources\\image\\filelddata\\field0.png", MAPINFO_BUFFER

    field_width_max = getImageWidth(MAPINFO_BUFFER) * MAPCHIP_EDGE_POINT
    field_height_max = getImageHeight(MAPINFO_BUFFER) * MAPCHIP_EDGE_POINT
    buffer MAPFIELD_BUFFER, field_width_max, field_height_max
    player_castle_x = 0.0
    player_castle_y = 0.0
    enemy_castle_x = 0.0
    enemy_castle_y = 0.0
    repeat getImageHeight(MAPINFO_BUFFER)
        y = cnt
        repeat getImageWidth(MAPINFO_BUFFER)
            x = cnt
            gsel MAPINFO_BUFFER
            pget x, y
            chip_id = ginfo_r
            enemytank_id = ginfo_g
            castle_id = ginfo_b
            gsel MAPFIELD_BUFFER
            // マップチップ情報を書き込む
            mapchip_div_id(x, y) = chip_id
            pos x * MAPCHIP_EDGE_POINT, y * MAPCHIP_EDGE_POINT
            celput MAPCHIP_HANDLER, mapchip_div_id(x, y)
            // 敵戦車情報のとき、そこに敵戦車を配置
            if enemytank_id != 255 {
                launch_side = 1
                launch_tank_id = enemytank_id
                enemy_launch_x = double(x * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2)
                enemy_launch_y = double(y * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2)
                gosub *game_tank_launch
            }
            // 陣地情報のとき、そこに陣地を配置
            if castle_id == 1 {
                player_castle_x = double(x * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2)
                player_castle_y = double(y * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2)
            } else: if castle_id == 2 {
                enemy_castle_x = double(x * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2)
                enemy_castle_y = double(y * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2)
            }
        loop
    loop
    // プレイヤー陣地の座標にターゲットを塗り替える
    repeat ENEMY_COUNT, ENEMY_BASE_INDEX
        if tank_used(cnt) {
            tank_target_x(cnt) = player_castle_x
            tank_target_y(cnt) = player_castle_y
        }
    loop
    gsel 0
    gosub *game_init_minimap

    // カメラの初期化
    camera_x = player_castle_x
    camera_y = player_castle_y
    camera_expand = 1.0

    // ダイアログ透過率
    dialog_alpha = 0

    // モード指定子の初期化
    mode_focus_castle = false
    mode_focus_tank = false
    mode_dialog = false
    mode_map = false
    mode_command_ahead = false
    mode_command_formation = false

    // ログ関連変数の初期化
    log_publish = false // ログを出力する際にtrueにする
    log_buffer = "" // ログ内容
    log_timer = 0 // ログを出力するループ時間

    // 範囲選択変数の初期化
    select_area_x1 = -1
    select_area_y1 = -1
    select_area_x2 = -1
    select_area_y2 = -1

    // ゲームループカウンターの初期化
    counter = 0

    // 中隊番号の初期化
    company_id = 0

// ゲームループ
*gameloop
    redraw 0

    // 何らかのモードであるかどうか
    not_some_mode = mode_focus_castle == false && mode_focus_tank == false && mode_map == false

    // 描画
    gosub *gamedraw

    // 更新
    gosub *gameupdate

    redraw 1
    await 16
goto *gameloop

// ゲームの画面描画
*gamedraw
    // 背景描画
    gmode 0
    pos 0, 0
    gzoom WINDOW_WIDTH, WINDOW_HEIGHT, MAPFIELD_BUFFER, (camera_x - double(WINDOW_WIDTH / 2) / camera_expand), (camera_y - double(WINDOW_HEIGHT / 2) / camera_expand), double(WINDOW_WIDTH) / camera_expand, double(WINDOW_HEIGHT) / camera_expand, 1
    gmode 2

    // 陣地描画
    posRelative player_castle_x - getImageWidth(BASE_HANDLER) / 2, player_castle_y - getImageHeight(BASE_HANDLER) / 2
    celput BASE_HANDLER, 0, camera_expand, camera_expand

    // 敵陣描画
    posRelative enemy_castle_x - getImageWidth(BASE_HANDLER) / 2, enemy_castle_y - getImageHeight(BASE_HANDLER) / 2
    celput BASE_HANDLER, 0, camera_expand, camera_expand

    // 自陣選択モードのとき
    if mode_focus_castle {
        // カーソルを自陣に描画
        posRelative player_castle_x, player_castle_y
        celput CURSOR_HANDLER, int(counter / 20) \ 2, 2.0 * camera_expand, 2.0 * camera_expand
        // 出撃可能範囲を描画
        color 0, 255, 0
        circleRelative player_castle_x - 128, player_castle_y - 128, player_castle_x + 128, player_castle_y + 128
        posRelative player_castle_x, player_castle_y - 128
        px = ginfo_cx : py = ginfo_cy
        font "ＭＳ ゴシック", 9
        pos px - getMesWidth("出撃可能範囲") / 2, py - getMesHeight("出撃可能範囲")
        objcolor 0, 0, 0
        mes "出撃可能範囲", mesopt_outline
    }

    // 目的地への線を描画
    if mode_focus_tank {
        repeat listLen(selected_tank_index_list)
            if tank_target_selected(listGet(selected_tank_index_list, cnt)) {
                color 0, 0, 0
                lineRelative tank_x(listGet(selected_tank_index_list, cnt)), tank_y(listGet(selected_tank_index_list, cnt)), tank_target_x(listGet(selected_tank_index_list, cnt)), tank_target_y(listGet(selected_tank_index_list, cnt))
            }
        loop
    }

    // 戦車描画
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_used(cnt) {
            if cnt < PLAYER_COUNT || tank_found(cnt) { // プレイヤー戦車は常に表示、敵戦車は見つかったものだけ表示
                posRelative tank_x(cnt), tank_y(cnt)
                celput tank_image_handler(cnt), 0, camera_expand, camera_expand, tank_angle(cnt)
            }
        }
    loop

    // 砲弾描画
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_bullet_to(cnt) != -1 {
            angle = atan(tank_y(tank_bullet_to(cnt)) - tank_bullet_y(cnt), tank_x(tank_bullet_to(cnt)) - tank_bullet_x(cnt))
            posRelative tank_bullet_x(cnt), tank_bullet_y(cnt)
            celput BULLET_HANDLER, , camera_expand, camera_expand, angle
        }
    loop

    // 戦車選択モードのとき
    if mode_focus_tank {
        repeat listLen(selected_tank_index_list)
            i = listGet(selected_tank_index_list, cnt)
            // カーソルを選択した戦車に描画
            posRelative tank_x(i), tank_y(i)
            celput CURSOR_HANDLER, int(counter / 20) \ 2, 0.5 * camera_expand, 0.5 * camera_expand
            // 戦車の名前を描画
            objcolor 0, 0, 0
            color 255, 255, 255
            posRelative tank_x(i), tank_y(i) + double(tank_image_height(i) / 2)
            px = ginfo_cx : py = ginfo_cy
            pos px - double(getMesWidth(tankdata_name(tank_id(i))) / 2), py
            mes tankdata_name(tank_id(i)), mesopt_outline
            // 戦車のHPバーを表示
            color 255, 0, 0
            boxfRelative tank_x(i) - 16.0, tank_y(i) - double(tank_image_height(i) / 2) - 6.0, tank_x(i) - 16.0 + 32.0 * (double(tank_hp(i)) / double(tankdata_hp(tank_id(i)))), tank_y(i) - double(tank_image_height(i) / 2)
            // リロードバーを描画
            color 255, 255, 0
            boxfRelative tank_x(i) - 16.0, tank_y(i) - double(tank_image_height(i) / 2) - 2.0, tank_x(i) - 16.0 + 32.0 * (1.0 - double(tank_reload_time(i)) / double(tankdata_reload_time(tank_id(i)))), tank_y(i) - double(tank_image_height(i) / 2)
            // 視認範囲を描画
            color 0, 0, 255
            circleRelative tank_x(i) - tank_visible_range(i), tank_y(i) - tank_visible_range(i), tank_x(i) + tank_visible_range(i), tank_y(i) + tank_visible_range(i)
            // 射程範囲を描画
            color 255, 0, 0
            circleRelative tank_x(i) - tank_range(i), tank_y(i) - tank_range(i), tank_x(i) + tank_range(i), tank_y(i) + tank_range(i)
            // 隊長車の上にフラッグを描画
            if tank_company(i) != -1 && tank_company_leader(i) == i {
                posRelative tank_x(i), tank_y(i) - (double(tank_image_height(i)) * camera_expand) / 2.0
                pos ginfo_cx - 8, ginfo_cy - 16
                celput FLAG_HANDLER
            }
        loop
    }

    // 戦車がダメージを受けたとき、そのダメージ量を描画
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_damaged_display_time(cnt) > 0 {
            objcolor 0, 0, 0
            color 255, 0, 0
            if tank_damaged_amount(cnt) > 0 {
                damage_str = str(tank_damaged_amount(cnt))
            } else: if tank_damaged_amount(cnt) == 0 {
                damage_str = "NODAMAGE"
            } else: if tank_damaged_amount(cnt) == -1 {
                damage_str = "MISS"
            }
            posRelative tank_x(cnt), tank_y(cnt) - double(tank_image_height(cnt) / 2) - double(getMesHeight(damage_str)) * sqrt(double(120 - tank_damaged_display_time(cnt)) / 120.0)
            px = ginfo_cx : py = ginfo_cy
            pos px - double(getMesWidth(damage_str) / 2), py
            mes damage_str, mesopt_outline
            tank_damaged_display_time(cnt)--
        }
    loop

    // 選択範囲描画
    getkey a, 1: if a && not_some_mode {
        color 100, 100, 255
        gmode 3, , , 128
        boxfRelative select_area_x1, select_area_y1, select_area_x2, select_area_y2
        gmode 2
    }

    // ログ描画
    if log_timer > 0 {
        pos -100, -100
        mesExpand log_buffer, 255, 255, 255, 15, 1, log_size, log_width, log_height
        pos double(WINDOW_WIDTH / 2) - double(log_width / 2) * log_size, 4
        mesExpand log_buffer, 255, 255, 255, 15, 1, log_size, log_width, log_height
        closerSpeedy log_size, 1.0, 0.3

        log_timer--
    }
    if log_publish {
        log_size = 0.0
        log_timer = 240
        log_publish = false
    }

    // マップボタンを描画
    if not_some_mode {
        pos 3, 3
        celput MAPBUTTON_HANDLER
    }

    // マップモードのときマップ描画
    if mode_map {
        select_area_x1 = -1
        select_area_y1 = -1
        gosub *game_draw_minimap
        boxfr minimap_base_x + camera_x / double(MAPCHIP_EDGE_POINT) - double(WINDOW_WIDTH) / (32.0 * camera_expand), minimap_base_y + camera_y / double(MAPCHIP_EDGE_POINT) - double(WINDOW_HEIGHT) / (32.0 * camera_expand), minimap_base_x + camera_x / double(MAPCHIP_EDGE_POINT) + double(WINDOW_WIDTH) / (32.0 * camera_expand), minimap_base_y + camera_y / double(MAPCHIP_EDGE_POINT) + double(WINDOW_HEIGHT) / (32.0 * camera_expand)
    }

    // ダイアログ描画
    gsel DIALOG_HANDLER
    color 0, 0, 0
    boxf
    gsel 0
    gmode 3, , , dialog_alpha
    pos WINDOW_WIDTH - DIALOG_SIZE_WIDTH, 0
    gcopy DIALOG_HANDLER, 0, 0, DIALOG_SIZE_WIDTH, DIALOG_SIZE_HEIGHT
    gmode 2

    // ダイアログ透過率
    if mode_dialog {
        intCloserTo dialog_alpha, 255, 20
    } else {
        intCloserTo dialog_alpha, 0, 20
    }

    // 出撃戦車選択モードのとき、自陣ダイアログを描画
    if mode_focus_castle {
        // 背景描画
        color 0, 0, 0
        boxf 0, WINDOW_HEIGHT - 100, WINDOW_WIDTH, WINDOW_HEIGHT
        // メッセージ描画
        pos 5, WINDOW_HEIGHT - 100 + 5
        color 255, 255, 255
        font "ＭＳ ゴシック", 9
        mes "プレイヤー拠点"
        // バツボタン描画
        color 150, 150, 150
        boxf WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70
        color 0, 0, 0
        line WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70
        line WINDOW_WIDTH - 10, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 30, WINDOW_HEIGHT - 70
        // 戦車ボタン描画
        repeat 5
            pos 74 * cnt + 10, WINDOW_HEIGHT - 82
            celput TANK_BADGE_HANDLER, 0
            color 255, 255, 255
            pos 74 * cnt + 10 + 32 - getMesWidth(tankdata_name(cnt)) / 2, WINDOW_HEIGHT - 82 + 64
            mes tankdata_name(cnt)
        loop
    }

    // 戦車フォーカスモードのとき、戦車命令ダイアログを描画
    if mode_focus_tank {
        // 背景描画
        color 0, 0, 0
        boxf 0, WINDOW_HEIGHT - 100, WINDOW_WIDTH, WINDOW_HEIGHT
        // メッセージ描画
        pos 5, WINDOW_HEIGHT - 100 + 5
        color 255, 255, 255
        font "ＭＳ ゴシック", 9
        mes "コマンド"
        // バツボタン描画
        color 150, 150, 150
        boxf WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70
        color 0, 0, 0
        line WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70
        line WINDOW_WIDTH - 10, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 30, WINDOW_HEIGHT - 70
        // 戦車ボタン描画
        repeat 5
            pos 74 * cnt + 10, WINDOW_HEIGHT - 82
            celput COMMAND_BADGE_HANDLER, cnt
        loop
    }

    // 目的地選択コマンドモードのとき、マップを描画
    if mode_command_ahead {
        gosub *game_draw_minimap
    }

    // 陣形選択モードのとき、フォーメーション選択ダイアログを描画
    if mode_command_formation {
        color 0, 0, 0
        boxf WINDOW_WIDTH / 2 - 306 / 2, WINDOW_HEIGHT / 2 - 104 / 2, WINDOW_WIDTH / 2 + 306 / 2, WINDOW_HEIGHT / 2 + 104 / 2
        font "ＭＳ ゴシック", 15
        pos WINDOW_WIDTH / 2 - 306 / 2 + 5, WINDOW_HEIGHT / 2 - 104 / 2 + 5
        color 255, 255, 255
        mes "フォーメーション選択"
        font "ＭＳ ゴシック", 9
        repeat 4
            pos WINDOW_WIDTH / 2 - 306 / 2 + (74 * cnt) + 10, WINDOW_HEIGHT / 2 - 104 / 2 + 30
            celput FORMATIONBUTTON_HANDLER, cnt
        loop
    }
return

// ゲームの更新
*gameupdate
    // フォーカスモードでないときマウス操作
    if not_some_mode {
        // カメラ操作(キーボード)
        getkey a, 37: if a: camera_x -= 10.0
        getkey a, 38: if a: camera_y -= 10.0
        getkey a, 39: if a: camera_x += 10.0
        getkey a, 40: if a: camera_y += 10.0

        // カメラ操作(マウス)
        getkey a, 2: if a{
            camera_x -= int(double(mousex - before_mx) * (1.0 / camera_expand))
            camera_y -= int(double(mousey - before_my) * (1.0 / camera_expand))
        }

        // 範囲指定
        getkey a, 1: if a {
            select_area_x2 = getMousePosX()
            select_area_y2 = getMousePosY()
        } else {
            // フィールドにある戦車を選択
            if select_area_x1 != -1 && select_area_y1 != -1 && select_area_x2 != -1 && select_area_y2 != -1 {
                gosub *game_area_select_player_tank
                if listLen(selected_tank_index_list) != 0 {
                    mode_focus_tank = true
                }
            }
            select_area_x1 = -1
            select_area_y1 = -1
            select_area_x2 = -1
            select_area_y2 = -1
        }
    }
    before_mx = mousex
    before_my = mousey

    // 自陣フォーカスモードのとき物体にカメラを近づける
    if mode_focus_castle {
        closerSpeedy camera_x, player_castle_x, 0.1
        closerSpeedy camera_y, player_castle_y, 0.1
    }

    // 戦車フォーカスモードのとき物体にカメラを近づける
    if mode_focus_tank {
        // 選択された戦車の重心を求める
        selected_tank_gx = 0.0
        selected_tank_gy = 0.0
        repeat listLen(selected_tank_index_list)
            selected_tank_gx += tank_x(listGet(selected_tank_index_list, cnt))
            selected_tank_gy += tank_y(listGet(selected_tank_index_list, cnt))
        loop
        selected_tank_gx /= double(listLen(selected_tank_index_list))
        selected_tank_gy /= double(listLen(selected_tank_index_list))
        closerSpeedy camera_x, selected_tank_gx, 0.1
        closerSpeedy camera_y, selected_tank_gy, 0.1
    }

    // マウスホイールによる拡大縮小
    diff = double(mousew - before_mw) * 0.001
    camera_expand += diff
    if camera_expand > 2.0: camera_expand = 2.0
    if camera_expand < 0.2: camera_expand = 0.2
    before_mw = mousew

    // マップモードのとき、マウスの視点移動
    if mode_map {
        getkey a, 1: if a && inRect(mousex, mousey, minimap_base_x, minimap_base_y, minimap_base_x + field_width_max / double(MAPCHIP_EDGE_POINT), minimap_base_y + field_height_max / double(MAPCHIP_EDGE_POINT)) {
            closerSpeedy camera_x, double((mousex - minimap_base_x) * MAPCHIP_EDGE_POINT) - double(MAPCHIP_EDGE_POINT) / 2.0, 0.2
            closerSpeedy camera_y, double((mousey - minimap_base_y) * MAPCHIP_EDGE_POINT) - double(MAPCHIP_EDGE_POINT) / 2.0, 0.2
        }
    }

    // カメラの範囲外抑制
    if camera_x - double(WINDOW_WIDTH / 2) / camera_expand < 0 {
        camera_x = double(WINDOW_WIDTH / 2) / camera_expand
    } else: if camera_x + double(WINDOW_WIDTH / 2) / camera_expand > field_width_max {
        camera_x = field_width_max - double(WINDOW_WIDTH / 2) / camera_expand
    }
    if camera_y < double(WINDOW_HEIGHT / 2) / camera_expand {
        camera_y = double(WINDOW_HEIGHT / 2) / camera_expand
    } else: if camera_y + double(WINDOW_HEIGHT / 2) / camera_expand > field_height_max {
        camera_y = field_height_max - double(WINDOW_HEIGHT / 2) / camera_expand
    }

    // 画面がクリックされたとき
    if mouseLeftClicked() {
        gosub *game_mouseleftclicked
    }
    if mouseRightClicked() {
        gosub *game_mouserightclicked
    }

    // 戦車の動き
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_used(cnt) && tank_stop(cnt) == false && tank_aiming(cnt) == false {
            if tank_target_selected(cnt) && tank_company(cnt) == -1 { // 中隊に属していないとき
                tank_angle(cnt) = atan(tank_target_y(cnt) - tank_y(cnt), tank_target_x(cnt) - tank_x(cnt))
                tank_xv = cos(tank_angle(cnt)) * tank_speed(cnt)
                tank_yv = sin(tank_angle(cnt)) * tank_speed(cnt)
            } else: if tank_company(cnt) != -1 { // 中隊に属しているとき
                if tank_company_leader(cnt) = cnt { // 隊長のとき
                    tank_angle(cnt) = atan(tank_target_y(cnt) - tank_y(cnt), tank_target_x(cnt) - tank_x(cnt))
                    tank_xv = cos(tank_angle(cnt)) * tank_company_speed(cnt)
                    tank_yv = sin(tank_angle(cnt)) * tank_company_speed(cnt)
                } else { // 隊長でないとき
                    companyFormationPosition target_x, target_y, cnt, 64
                    if tank_stop(tank_company_leader(cnt)) || tank_target_selected(tank_company_leader(cnt)) == false || tank_aiming(tank_company_leader(cnt)) { // 隊長が動いていないとき
                        tank_target_x(cnt) = target_x
                        tank_target_y(cnt) = target_y
                    } else { // 隊長が動いているとき
                        tank_target_x(cnt) = target_x + (cos(tank_angle(tank_company_leader(cnt))) * tank_company_speed(tank_company_leader(cnt))) * (distance(tank_x(cnt), tank_y(cnt), target_x, target_y) / tank_speed(cnt))
                        tank_target_y(cnt) = target_y + (sin(tank_angle(tank_company_leader(cnt))) * tank_company_speed(tank_company_leader(cnt))) * (distance(tank_x(cnt), tank_y(cnt), target_x, target_y) / tank_speed(cnt))
                    }
                    tank_angle(cnt) = atan(tank_target_y(cnt) - tank_y(cnt), tank_target_x(cnt) - tank_x(cnt))
                    if distance(tank_x(cnt), tank_y(cnt), tank_target_x(cnt), tank_target_y(cnt)) < 3 {
                        tank_xv = cos(tank_angle(cnt)) * tank_company_speed(cnt)
                        tank_yv = sin(tank_angle(cnt)) * tank_company_speed(cnt)
                    } else {
                        tank_xv = cos(tank_angle(cnt)) * tank_speed(cnt)
                        tank_yv = sin(tank_angle(cnt)) * tank_speed(cnt)
                    }
                }
            }
            if distance(tank_x(cnt), tank_y(cnt), tank_target_x(cnt), tank_target_y(cnt)) >= 3 {
                tank_x(cnt) += tank_xv
                tank_y(cnt) += tank_yv
            }
            if distance(tank_x(cnt), tank_y(cnt), tank_target_x(cnt), tank_target_y(cnt)) < 3 && (tank_company(cnt) == -1 || (tank_company(cnt) != -1 && tank_company_number(cnt) == 0)) {
                tank_stop(cnt) = true
                tank_target_selected(cnt) = false
                if cnt < PLAYER_COUNT {
                    log_buffer = "戦車が目的地に到着しました"
                    log_publish = true
                }
            }
        }

        if tank_used(cnt) && tank_aiming(cnt) {
            tank_angle(cnt) = atan(tank_aim_y(cnt) - tank_y(cnt), tank_aim_x(cnt) - tank_x(cnt))
        }
    loop

    // 双方敵戦車を発見する
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_used(cnt) {
            if cnt < PLAYER_COUNT {
                repeat_counter = ENEMY_COUNT
                repeat_base = ENEMY_BASE_INDEX
            } else {
                repeat_counter = PLAYER_COUNT
                repeat_base = PLAYER_BASE_INDEX
            }
            from_cnt = cnt
            repeat repeat_counter, repeat_base
                if tank_used(cnt) && distance(tank_x(cnt), tank_y(cnt), tank_x(from_cnt), tank_y(tank_cnt)) < tank_visible_range(from_cnt) {
                    if from_cnt < PLAYER_COUNT && tank_found(cnt) == false {
                        log_buffer = "敵戦車を発見しました"
                        log_publish = true
                    }
                    tank_found(cnt) = true
                    tank_found_timer(cnt) = 600
                }
            loop
        }
    loop

    // 発見から10秒経ったら見失う
    repeat ENEMY_COUNT, ENEMY_BASE_INDEX
        if tank_used(cnt) && tank_found(cnt) {
            tank_found_timer(cnt)--
            if tank_found_timer(cnt) == 0 {
                tank_found(cnt) = false
            }
        }
    loop

    // 砲弾の位置の更新
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_bullet_to(cnt) != -1 {
            angle = atan(tank_y(tank_bullet_to(cnt)) - tank_bullet_y(cnt), tank_x(tank_bullet_to(cnt)) - tank_bullet_x(cnt))
            doubleCloserTo tank_bullet_x(cnt), tank_x(tank_bullet_to(cnt)), absf(cos(angle) * 50.0)
            doubleCloserTo tank_bullet_y(cnt), tank_y(tank_bullet_to(cnt)), absf(sin(angle) * 50.0)
            if distance(tank_bullet_x(cnt), tank_bullet_y(cnt), tank_x(tank_bullet_to(cnt)), tank_y(tank_bullet_to(cnt))) < 8.0 {
                if tank_used(tank_bullet_to(cnt)) {
                    tank_damaged_display_time(tank_bullet_to(cnt)) = 120
                    attack cnt, tank_bullet_to(cnt), tank_damaged_amount(tank_bullet_to(cnt))
                }
                tank_bullet_to(cnt) = -1
            }
        }
    loop

    // 中隊に属しており、隊長が自身の中隊に属していないとき、自分を中隊から外す
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_company(cnt) != -1 {
           if tank_company(tank_company_leader(cnt)) != tank_company(cnt) {
               tank_company(cnt) = -1
           }
        }
    loop

    // 戦車の死亡確認
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_used(cnt) && tank_hp(cnt) <= 0 {
            tank_used(cnt) = false
            listRemoveVal selected_tank_index_list, cnt
        }
    loop

    // 選択中戦車が全て死亡した場合フォーカスモードを解除
    if listLen(selected_tank_index_list) == 0 {
        mode_focus_tank = false
    }

    // 砲弾装填
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_used(cnt) && tank_reload_time(cnt) > 0 {
            tank_reload_time(cnt)--
        }
    loop

    // 自動攻撃
    gosub *game_tankattack

    // メインループカウンター
    counter++
return

// ゲーム中にマウス左ボタンがクリックされたときのサブルーチン
*game_mouseleftclicked
    mx = getMousePosX()
    my = getMousePosY()

    // 何かのモードにする
    if not_some_mode {
        // 自陣選択モード
        if inRect(mx, my, player_castle_x - 64, player_castle_y - 64, player_castle_x + 64, player_castle_y + 64) && mode_focus_castle == false && mode_focus_tank == false{ // 自陣をクリックしたとき
            mode_focus_castle = true
            return
        }
        // マップモード
        if inRect(mousex, mousey, 3, 3, 3 + getImageWidth(MAPBUTTON_HANDLER), 3 + getImageHeight(MAPBUTTON_HANDLER)) { // 左上のボタンをクリックしたとき
            mode_map = true
            return
        }
    }

    // 自陣ダイアログでのマウスの動作
    if mode_focus_castle {
        if inRect(mousex, mousey, WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70) { //バツボタンが押されたとき
            mode_focus_castle = false
            return
        }
        repeat 5
            if inRect(mousex, mousey, 74 * cnt + 10, WINDOW_HEIGHT - 82, 74 * cnt + 10 + 64, WINDOW_HEIGHT - 82 + 64) {
                launch_side = 0 // プレイヤー
                launch_tank_id = cnt // 戦車の種類ID
                gosub *game_tank_launch
            }
        loop
        return
    }

    // 戦車フォーカスモードでのマウスの動作
    if mode_focus_tank && mode_command_ahead == false{
        if inRect(mousex, mousey, WINDOW_WIDTH - 30, WINDOW_HEIGHT - 90, WINDOW_WIDTH - 10, WINDOW_HEIGHT - 70) { //バツボタンが押されたとき
            mode_focus_tank = false
            return
        }
        repeat 5
            if inRect(mousex, mousey, 74 * cnt + 10, WINDOW_HEIGHT - 82, 74 * cnt + 10 + 64, WINDOW_HEIGHT - 82 + 64) {
                switch cnt
                    case 0: // 目的地選択
                        mode_command_ahead = true
                        swbreak
                    case 1: // 動く
                        repeat listLen(selected_tank_index_list)
                            if tank_target_selected(listGet(selected_tank_index_list, cnt)) {
                                tank_stop(listGet(selected_tank_index_list, cnt)) = false
                            }
                        loop
                        swbreak
                    case 2: // 停まる
                        repeat listLen(selected_tank_index_list)
                            tank_stop(listGet(selected_tank_index_list, cnt)) = true
                        loop
                        swbreak
                    case 4: // 陣形選択
                        mode_command_formation = true
                        swbreak
                swend
            }
        loop
    }

    // 目的地選択
    if mode_command_ahead {
        if inRect(mousex, mousey, minimap_base_x, minimap_base_y, minimap_base_x + field_width_max / double(MAPCHIP_EDGE_POINT), minimap_base_y + field_height_max / double(MAPCHIP_EDGE_POINT)) {
            repeat listLen(selected_tank_index_list)
                // 選択中の戦車が中隊に属しており、かつ選択された戦車の中にその隊長がいないとき、戦車を中隊から外す
                if tank_company(listGet(selected_tank_index_list, cnt)) != -1 && listContains(selected_tank_index_list, tank_company_leader(listGet(selected_tank_index_list, cnt))) == false {
                    tank_company(listGet(selected_tank_index_list, cnt)) = -1
                }
            loop
            // 選択された戦車の重心を求める
            selected_tank_gx = 0.0
            selected_tank_gy = 0.0
            c = 0
            repeat listLen(selected_tank_index_list)
                if tank_company(listGet(selected_tank_index_list, cnt)) == -1 { // 中隊に属していないとき
                    selected_tank_gx += tank_x(listGet(selected_tank_index_list, cnt))
                    selected_tank_gy += tank_y(listGet(selected_tank_index_list, cnt))
                    c++
                }
            loop
            if c != 0 {
                selected_tank_gx /= double(c)
                selected_tank_gy /= double(c)
            }
            repeat listLen(selected_tank_index_list)
                if tank_company(listGet(selected_tank_index_list, cnt)) == -1 { // 中隊に属していないとき
                    tank_target_x(listGet(selected_tank_index_list, cnt)) = double(mousex * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2 - minimap_base_x * MAPCHIP_EDGE_POINT) + (tank_x(listGet(selected_tank_index_list, cnt)) - selected_tank_gx)
                    tank_target_y(listGet(selected_tank_index_list, cnt)) = double(mousey * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2 - minimap_base_y * MAPCHIP_EDGE_POINT) + (tank_y(listGet(selected_tank_index_list, cnt)) - selected_tank_gy)
                } else: if tank_company_leader(listGet(selected_tank_index_list, cnt)) == listGet(selected_tank_index_list, cnt) { // 隊長のとき
                    tank_target_x(listGet(selected_tank_index_list, cnt)) = double(mousex * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2 - minimap_base_x * MAPCHIP_EDGE_POINT)
                    tank_target_y(listGet(selected_tank_index_list, cnt)) = double(mousey * MAPCHIP_EDGE_POINT - MAPCHIP_EDGE_POINT / 2 - minimap_base_y * MAPCHIP_EDGE_POINT)
                } else { // 隊長でないとき
                    companyFormationPosition tank_target_x(listGet(selected_tank_index_list, cnt)), tank_target_y(listGet(selected_tank_index_list, cnt)), cnt, 64
                }
                tank_stop(listGet(selected_tank_index_list, cnt)) = false
                tank_target_selected(listGet(selected_tank_index_list, cnt)) = true
            loop
        }
    }

    // フォーメーション選択
    if mode_command_formation {
        repeat 4
            if inRect(mousex, mousey, WINDOW_WIDTH / 2 - 306 / 2 + (74 * cnt) + 10, WINDOW_HEIGHT / 2 - 104 / 2 + 30, WINDOW_WIDTH / 2 - 306 / 2 + (74 * cnt) + 10 + 64, WINDOW_HEIGHT / 2 - 104 / 2 + 30 + 64) {
                formation = cnt
                gosub *game_make_company
                mode_command_formation = false
            }
        loop
    }

    // 選択範囲指定の最初地点の設定
    select_area_x1 = mx
    select_area_y1 = my
return

// ゲーム中にマウス右ボタンがクリックされたときのサブルーチン
*game_mouserightclicked
    mx = getMousePosX()
    my = getMousePosY()

    if mode_focus_castle {
        mode_focus_castle = false
    }

    if mode_map {
        mode_map = false
    }

    if mode_focus_tank && mode_command_ahead == false && mode_command_formation == false{
        mode_focus_tank = false
        listClear selected_tank_index_list
        repeat PLAYER_COUNT
            tank_selected(cnt) = false
        loop
    }

    if mode_command_formation {
        mode_command_formation = false
        return
    }

    if mode_command_ahead {
        mode_command_ahead = false
        return
    }
return

// 戦車をマップに出現させる処理
*game_tank_launch
    if launch_side == 0 {
        repeat_counter = PLAYER_COUNT
        repeat_base = PLAYER_BASE_INDEX
    } else {
        repeat_counter = ENEMY_COUNT
        repeat_base = ENEMY_BASE_INDEX
    }
    repeat repeat_counter, repeat_base
        if tank_used(cnt) == false {
            tank_used(cnt) = true
            copyStatus cnt, launch_tank_id
            if launch_side == 0 {
                tank_angle(cnt) = (3.0 * M_PI) / 2.0
                tank_stop(cnt) = true
                launch_id = cnt
                gosub *game_playertank_launch_placement
            } else {
                tank_angle(cnt) = -(3.0 * M_PI) / 2.0
                tank_stop(cnt) = false
                tank_x(cnt) = enemy_launch_x
                tank_y(cnt) = enemy_launch_y
                //TODO: とりあえず
                tank_target_selected(cnt) = true
                tank_target_x(cnt) = player_castle_x
                tank_target_y(cnt) = player_castle_y
            }
            tank_operation(cnt) = OPERATION_ATTACK_TO_NEAR
            tank_reload_time(cnt) = 0
            tank_found(cnt) = false
            tank_company(cnt) = -1
            tank_bullet_to(cnt) = -1
            tank_aiming(cnt) = false
            tank_damaged_display_time(cnt) = 0
            break
        }
    loop
return

// 出現する戦車の場所を決める
*game_playertank_launch_placement
    tank_x(launch_id) = player_castle_x
    tank_y(launch_id) = player_castle_y - 128
    tank_target_x(launch_id) = player_castle_x
    tank_target_y(launch_id) = player_castle_y - 128
    tank_target_selected(launch_id) = false
    launch_counter = 1000
    repeat PLAYER_COUNT + ENEMY_COUNT
        if launch_id == cnt: continue
        if launch_counter == 0 {
            log_publish = true
            log_buffer = "出撃可能な範囲がありません"
            tank_used(launch_id) = false
            break
        }
        if tank_used(cnt) && hitRect(tank_x(launch_id) - 16, tank_y(launch_id) - 16, tank_x(launch_id) + 16, tank_y(launch_id) + 16, tank_x(cnt) - 16, tank_y(cnt) - 16, tank_x(cnt) + 16, tank_y(cnt) + 16) {
            rand_angle = deg2rad(rnd(360))
            rand_r = 32 + rnd(128 - 32)
            tank_selected(launch_id) = false
            tank_x(launch_id) = cos(rand_angle) * rand_r + player_castle_x
            tank_y(launch_id) = sin(rand_angle) * rand_r + player_castle_y
            tank_target_x(launch_id) = cos(rand_angle) * rand_r + player_castle_x
            tank_target_y(launch_id) = sin(rand_angle) * rand_r + player_castle_y
            launch_counter--
            continue 0
        }
    loop
return

// 範囲選択した際の処理
*game_area_select_player_tank
    listClear selected_tank_index_list
    repeat PLAYER_COUNT
        if tank_used(cnt) == false: continue
        if inRect(tank_x(cnt), tank_y(cnt), select_area_x1, select_area_y1, select_area_x2, select_area_y2) {
            listAppend selected_tank_index_list, cnt
            tank_selected(cnt) = true
        }
    loop
return

// ミニマップの初期化
*game_init_minimap
    gsel MINIMAP_BUFFER
    repeat field_height_max / MAPCHIP_EDGE_POINT
        x = cnt
        repeat field_width_max / MAPCHIP_EDGE_POINT
            y = cnt
            color 0, 255, 0
            pset x, y
        loop
    loop
    gsel 0
return

// ミニマップの描画
*game_draw_minimap
    // 基準点
    minimap_base_x = WINDOW_WIDTH / 2 - (field_width_max / MAPCHIP_EDGE_POINT) / 2
    minimap_base_y = WINDOW_HEIGHT / 2 - (field_height_max / MAPCHIP_EDGE_POINT) / 2
    // マップ描画
    pos minimap_base_x, minimap_base_y
    gmode 0
    gcopy MINIMAP_BUFFER, 0, 0, field_width_max / MAPCHIP_EDGE_POINT, field_height_max / MAPCHIP_EDGE_POINT
    // 戦車の位置の描画
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_used(cnt) && (cnt < PLAYER_COUNT || tank_found(cnt)) {
            if cnt < ENEMY_BASE_INDEX {
                if tank_selected(cnt) && (counter / 20) \ 2 {
                    color 255, 255, 0
                } else {
                    color 0, 0, 255
                }
            } else {
                color 255, 0, 0
            }
            psetBig minimap_base_x + tank_x(cnt) / double(MAPCHIP_EDGE_POINT), minimap_base_y + tank_y(cnt) / double(MAPCHIP_EDGE_POINT), 2
        }
    loop
    // 自陣描画
    color 0, 0, 0
    psetBig minimap_base_x + player_castle_x / double(MAPCHIP_EDGE_POINT), minimap_base_y + player_castle_y / double(MAPCHIP_EDGE_POINT), 2
    // 敵陣描画
    color 0, 0, 0
    psetBig minimap_base_x + enemy_castle_x / double(MAPCHIP_EDGE_POINT), minimap_base_y + enemy_castle_y / double(MAPCHIP_EDGE_POINT), 2
    gmode 2
return

// 中隊への参加処理
*game_make_company
    speed_min = 100.0
    hp_max = 0
    hp_max_index = 0
    repeat listLen(selected_tank_index_list)
        if speed_min > tank_speed(listGet(selected_tank_index_list, cnt)) {
            speed_min = tank_speed(listGet(selected_tank_index_list, cnt))
        }
        if hp_max < tank_hp(listGet(selected_tank_index_list, cnt)) {
            hp_max = tank_hp(listGet(selected_tank_index_list, cnt))
            hp_max_index = cnt
        }
    loop
    repeat listLen(selected_tank_index_list)
        if formation == COMPAMYFORMATION_OFF { // 選択中の戦車を中隊から外す
            tank_company(listGet(selected_tank_index_list, cnt)) = -1
            continue
        }
        tank_company(listGet(selected_tank_index_list, cnt)) = company_id
        if hp_max_index == cnt {
            tank_company_number(listGet(selected_tank_index_list, cnt)) = 0
        } else: if hp_max_index > cnt {
            tank_company_number(listGet(selected_tank_index_list, cnt)) = cnt + 1
        } else {
            tank_company_number(listGet(selected_tank_index_list, cnt)) = cnt
        }
        tank_company_speed(listGet(selected_tank_index_list, cnt)) = speed_min
        if cnt != hp_max_index {
            tank_stop(listGet(selected_tank_index_list, cnt)) = false
            tank_target_selected(listGet(selected_tank_index_list, cnt)) = true
        }
        tank_company_formation(listGet(selected_tank_index_list, cnt)) = formation
        tank_company_leader(listGet(selected_tank_index_list, cnt)) = listGet(selected_tank_index_list, hp_max_index)
    loop

    company_id++
return


// 戦車の自動攻撃
*game_tankattack
    repeat PLAYER_COUNT + ENEMY_COUNT
        if tank_used(cnt) {
            // 照準対象を選択
            shoot_from = cnt
            shoot_to = -1
            if shoot_from < PLAYER_COUNT {
                repeat_counter = ENEMY_COUNT
                repeat_base = ENEMY_BASE_INDEX
            } else {
                repeat_counter = PLAYER_COUNT
                repeat_base = PLAYER_BASE_INDEX
            }
            switch tank_operation(shoot_from)
                case OPERATION_ATTACK_TO_NEAR: // 一番近い戦車を攻撃
                    near_distance = 10000000000.0
                    repeat repeat_counter, repeat_base
                        if tank_used(cnt) {
                            current_distance = distance(tank_x(shoot_from), tank_y(shoot_from), tank_x(cnt), tank_y(cnt))
                            if current_distance < near_distance && current_distance < tank_range(shoot_from) && tank_found(cnt) {
                                near_distance = current_distance
                                shoot_to = cnt
                            }
                        }
                    loop
                    swbreak
                case OPERATION_ATTACK_TO_STRONGER: // 一番最大体力が高い戦車を攻撃
                    repeat repeat_counter, repeat_base
                        if tank_used(cnt) && distance(tank_x(shoot_from), tank_y(shoot_from), tank_x(cnt), tank_y(cnt)) < tank_range(shoot_from) && tank_found(cnt) {
                            if shoot_to == -1 {
                                shoot_to = cnt
                                continue
                            }
                            if tankdata_hp(tank_id(cnt)) > tankdata_hp(tank_id(shoot_to)) {
                                shoot_to = cnt
                            }
                        }
                    loop
                    swbreak
                case OPERATION_ATTACK_TO_SPECIFIED: // 優先攻撃指定された戦車からランダムに攻撃
                    if listLen(specified_tank_index_list) == 0: swbreak
                    listShuffle specified_tank_index_list
                    repeat listLen(specified_tank_index_list)
                        if distance(tank_x(shoot_from), tank_y(shoot_from), tank_x(listGet(specified_tank_index_list, cnt)), tank_y(listGet(specified_tank_index_list, cnt))) < tank_range(shoot_from) && tank_found(listGet(specified_tank_index_list, cnt)) {
                            shoot_to = listGet(specified_tank_index_list, cnt)
                        }
                    loop
                    swbreak
                case OPERATION_IGNORE: // 敵戦車を無視
                    // 何もしない
                    swbreak
            swend

            // 対象がいないときは照準解除
            if shoot_to = -1 {
                tank_aiming(shoot_from) = false
                continue
            }

            // 照準をあわせる
            tank_aiming(shoot_from) = true
            tank_aim_x(shoot_from) = tank_x(shoot_to)
            tank_aim_y(shoot_from) = tank_y(shoot_to)

            // 攻撃
            if tank_reload_time(shoot_from) == 0 {
                tank_reload_time(shoot_from) = tankdata_reload_time(tank_id(shoot_from))
                tank_bullet_to(shoot_from) = shoot_to
                angle = atan(tank_y(shoot_to) - tank_y(shoot_from), tank_x(shoot_to) - tank_x(shoot_from))
                tank_bullet_x(shoot_from) = tank_x(shoot_from) + cos(angle) * 40.0
                tank_bullet_y(shoot_from) = tank_y(shoot_from) + sin(angle) * 40.0
            }
        }
    loop
return